// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: carshare_messaging.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// This is treated as a bitfield so we can set multiple permissions in one integer.
/// Packed into a fixed 32 bit type instead of varint encoding as we'll often set the high bits.
/// Beyond 32 permissions, we have to start a new enum type and permissions field.
enum PermissionFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case permissionsNone // = 0
  case lock // = 1
  case unlockDriver // = 2
  case unlockAll // = 4
  case openTrunk // = 8
  case closeTrunk // = 16
  case locate // = 32
  case immobilize // = 64
  case mobilize // = 128
  case panicAlarmOn // = 256
  case panicAlarmOff // = 512
  case checkin // = 1024
  case checkout // = 2048
  case connect // = 4096
  case disconnect // = 8192
  case observe // = 16384
  case createReservation // = 32768
  case readReservation // = 65536
  case modifyReservation // = 131072
  case deleteReservation // = 262144
  case serviceModeRequest // = 524288
  case blacklistUser // = 1048576
  case remoteStart // = 2097152
  case UNRECOGNIZED(Int)

  init() {
    self = .permissionsNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .permissionsNone
    case 1: self = .lock
    case 2: self = .unlockDriver
    case 4: self = .unlockAll
    case 8: self = .openTrunk
    case 16: self = .closeTrunk
    case 32: self = .locate
    case 64: self = .immobilize
    case 128: self = .mobilize
    case 256: self = .panicAlarmOn
    case 512: self = .panicAlarmOff
    case 1024: self = .checkin
    case 2048: self = .checkout
    case 4096: self = .connect
    case 8192: self = .disconnect
    case 16384: self = .observe
    case 32768: self = .createReservation
    case 65536: self = .readReservation
    case 131072: self = .modifyReservation
    case 262144: self = .deleteReservation
    case 524288: self = .serviceModeRequest
    case 1048576: self = .blacklistUser
    case 2097152: self = .remoteStart
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .permissionsNone: return 0
    case .lock: return 1
    case .unlockDriver: return 2
    case .unlockAll: return 4
    case .openTrunk: return 8
    case .closeTrunk: return 16
    case .locate: return 32
    case .immobilize: return 64
    case .mobilize: return 128
    case .panicAlarmOn: return 256
    case .panicAlarmOff: return 512
    case .checkin: return 1024
    case .checkout: return 2048
    case .connect: return 4096
    case .disconnect: return 8192
    case .observe: return 16384
    case .createReservation: return 32768
    case .readReservation: return 65536
    case .modifyReservation: return 131072
    case .deleteReservation: return 262144
    case .serviceModeRequest: return 524288
    case .blacklistUser: return 1048576
    case .remoteStart: return 2097152
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PermissionFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PermissionFlags] = [
    .permissionsNone,
    .lock,
    .unlockDriver,
    .unlockAll,
    .openTrunk,
    .closeTrunk,
    .locate,
    .immobilize,
    .mobilize,
    .panicAlarmOn,
    .panicAlarmOff,
    .checkin,
    .checkout,
    .connect,
    .disconnect,
    .observe,
    .createReservation,
    .readReservation,
    .modifyReservation,
    .deleteReservation,
    .serviceModeRequest,
    .blacklistUser,
    .remoteStart,
  ]
}

#endif  // swift(>=4.2)

enum VehicleSecureConditionsFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case secureConditionNone // = 0
  case windowsUp // = 1
  case sunroofClosed // = 2
  case convertibleClosed // = 4
  case doorsClosed // = 8
  case ignitionOff // = 16
  case lightsOff // = 32
  case UNRECOGNIZED(Int)

  init() {
    self = .secureConditionNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .secureConditionNone
    case 1: self = .windowsUp
    case 2: self = .sunroofClosed
    case 4: self = .convertibleClosed
    case 8: self = .doorsClosed
    case 16: self = .ignitionOff
    case 32: self = .lightsOff
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .secureConditionNone: return 0
    case .windowsUp: return 1
    case .sunroofClosed: return 2
    case .convertibleClosed: return 4
    case .doorsClosed: return 8
    case .ignitionOff: return 16
    case .lightsOff: return 32
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VehicleSecureConditionsFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [VehicleSecureConditionsFlags] = [
    .secureConditionNone,
    .windowsUp,
    .sunroofClosed,
    .convertibleClosed,
    .doorsClosed,
    .ignitionOff,
    .lightsOff,
  ]
}

#endif  // swift(>=4.2)

/// This is the root message of the carshare messaging specification.
/// All protobug messages sent / received via BT-IOX for carshare are contained here.
/// Serialization/deserialization is always to/from this message.
struct AppToDeviceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var command: DeviceCommandMessage {
    get {
      if case .command(let v)? = _storage._message {return v}
      return DeviceCommandMessage()
    }
    set {_uniqueStorage()._message = .command(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case command(DeviceCommandMessage)

  #if !swift(>=4.1)
    static func ==(lhs: AppToDeviceMessage.OneOf_Message, rhs: AppToDeviceMessage.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.command(let l), .command(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DeviceToAppMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// TODO: add context to this message 
  var result: ResultMessage {
    get {
      if case .result(let v)? = _storage._message {return v}
      return ResultMessage()
    }
    set {_uniqueStorage()._message = .result(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    /// TODO: add context to this message 
    case result(ResultMessage)

  #if !swift(>=4.1)
    static func ==(lhs: DeviceToAppMessage.OneOf_Message, rhs: DeviceToAppMessage.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.result(let l), .result(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// For communication from Car Share framework to Go devices
struct DeviceCommandMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Command: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case noCommand // = 0
    case lock // = 1
    case unlockDriver // = 2
    case unlockAll // = 4
    case openTrunk // = 8
    case closeTrunk // = 16
    case locate // = 32
    case immobilize // = 64
    case mobilize // = 128
    case checkin // = 1024
    case checkout // = 2048
    case UNRECOGNIZED(Int)

    init() {
      self = .noCommand
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noCommand
      case 1: self = .lock
      case 2: self = .unlockDriver
      case 4: self = .unlockAll
      case 8: self = .openTrunk
      case 16: self = .closeTrunk
      case 32: self = .locate
      case 64: self = .immobilize
      case 128: self = .mobilize
      case 1024: self = .checkin
      case 2048: self = .checkout
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noCommand: return 0
      case .lock: return 1
      case .unlockDriver: return 2
      case .unlockAll: return 4
      case .openTrunk: return 8
      case .closeTrunk: return 16
      case .locate: return 32
      case .immobilize: return 64
      case .mobilize: return 128
      case .checkin: return 1024
      case .checkout: return 2048
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension DeviceCommandMessage.Command: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DeviceCommandMessage.Command] = [
    .noCommand,
    .lock,
    .unlockDriver,
    .unlockAll,
    .openTrunk,
    .closeTrunk,
    .locate,
    .immobilize,
    .mobilize,
    .checkin,
    .checkout,
  ]
}

#endif  // swift(>=4.2)

/// returned after challenge / response is complete
struct ResultMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceReservationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GO only supports a public exponent of 0x10001 so a modulus is enough to determine the public key
  var appPublicModulus: Data {
    get {return _storage._appPublicModulus}
    set {_uniqueStorage()._appPublicModulus = newValue}
  }

  var keyExpiry: UInt64 {
    get {return _storage._keyExpiry}
    set {_uniqueStorage()._keyExpiry = newValue}
  }

  var reservationID: String {
    get {return _storage._reservationID}
    set {_uniqueStorage()._reservationID = newValue}
  }

  var deviceHardwareID: UInt64 {
    get {return _storage._deviceHardwareID}
    set {_uniqueStorage()._deviceHardwareID = newValue}
  }

  var account: Account {
    get {return _storage._account ?? Account()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Timestamp represented by seconds since Unix Epoch
  var reservationStartTime: UInt64 {
    get {return _storage._reservationStartTime}
    set {_uniqueStorage()._reservationStartTime = newValue}
  }

  /// Timestamp represented by seconds since Unix Epoch
  var reservationEndTime: UInt64 {
    get {return _storage._reservationEndTime}
    set {_uniqueStorage()._reservationEndTime = newValue}
  }

  var gracePeriodSeconds: UInt32 {
    get {return _storage._gracePeriodSeconds}
    set {_uniqueStorage()._gracePeriodSeconds = newValue}
  }

  var securePeriodSeconds: UInt32 {
    get {return _storage._securePeriodSeconds}
    set {_uniqueStorage()._securePeriodSeconds = newValue}
  }

  var endBookConditions: EndBookConditions {
    get {return _storage._endBookConditions ?? EndBookConditions()}
    set {_uniqueStorage()._endBookConditions = newValue}
  }
  /// Returns true if `endBookConditions` has been explicitly set.
  var hasEndBookConditions: Bool {return _storage._endBookConditions != nil}
  /// Clears the value of `endBookConditions`. Subsequent reads from it will return its default value.
  mutating func clearEndBookConditions() {_uniqueStorage()._endBookConditions = nil}

  var proxCardID: UInt32 {
    get {return _storage._proxCardID}
    set {_uniqueStorage()._proxCardID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// enum Permission
  var permissions: PermissionList {
    get {return _storage._permissions ?? PermissionList()}
    set {_uniqueStorage()._permissions = newValue}
  }
  /// Returns true if `permissions` has been explicitly set.
  var hasPermissions: Bool {return _storage._permissions != nil}
  /// Clears the value of `permissions`. Subsequent reads from it will return its default value.
  mutating func clearPermissions() {_uniqueStorage()._permissions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Eventually we may have more than one permissions bitfield to send, this message encapsulates
/// all permissions bitfields (transmitted as 32-bit integers) in a single message.
struct PermissionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// enum PermissionFlags
  var permissions: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EndBookConditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleSecureConditions: VehicleSecureConditions {
    get {return _storage._vehicleSecureConditions ?? VehicleSecureConditions()}
    set {_uniqueStorage()._vehicleSecureConditions = newValue}
  }
  /// Returns true if `vehicleSecureConditions` has been explicitly set.
  var hasVehicleSecureConditions: Bool {return _storage._vehicleSecureConditions != nil}
  /// Clears the value of `vehicleSecureConditions`. Subsequent reads from it will return its default value.
  mutating func clearVehicleSecureConditions() {_uniqueStorage()._vehicleSecureConditions = nil}

  var homePoint: GpsCoordinate {
    get {return _storage._homePoint ?? GpsCoordinate()}
    set {_uniqueStorage()._homePoint = newValue}
  }
  /// Returns true if `homePoint` has been explicitly set.
  var hasHomePoint: Bool {return _storage._homePoint != nil}
  /// Clears the value of `homePoint`. Subsequent reads from it will return its default value.
  mutating func clearHomePoint() {_uniqueStorage()._homePoint = nil}

  var homeRadius: UInt32 {
    get {return _storage._homeRadius}
    set {_uniqueStorage()._homeRadius = newValue}
  }

  var fuelTankGreaterThan: Float {
    get {return _storage._fuelTankGreaterThan}
    set {_uniqueStorage()._fuelTankGreaterThan = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct VehicleSecureConditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// enum VehicleSecureConditionsFlags
  var vehicleSecureConditions: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GpsCoordinate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Float = 0

  var longitude: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Carshare Public Key Message
/// Generated in the Carshare Service, consumed by the Go device.
struct CarsharePublicKeyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp represented by seconds since Unix Epoch
  var rotationTimestamp: Int64 = 0

  /// An empty byte string on this property indicates that there is no active public key for the device 
  var publicModulus: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PermissionFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERMISSIONS_NONE"),
    1: .same(proto: "LOCK"),
    2: .same(proto: "UNLOCK_DRIVER"),
    4: .same(proto: "UNLOCK_ALL"),
    8: .same(proto: "OPEN_TRUNK"),
    16: .same(proto: "CLOSE_TRUNK"),
    32: .same(proto: "LOCATE"),
    64: .same(proto: "IMMOBILIZE"),
    128: .same(proto: "MOBILIZE"),
    256: .same(proto: "PANIC_ALARM_ON"),
    512: .same(proto: "PANIC_ALARM_OFF"),
    1024: .same(proto: "CHECKIN"),
    2048: .same(proto: "CHECKOUT"),
    4096: .same(proto: "CONNECT"),
    8192: .same(proto: "DISCONNECT"),
    16384: .same(proto: "OBSERVE"),
    32768: .same(proto: "CREATE_RESERVATION"),
    65536: .same(proto: "READ_RESERVATION"),
    131072: .same(proto: "MODIFY_RESERVATION"),
    262144: .same(proto: "DELETE_RESERVATION"),
    524288: .same(proto: "SERVICE_MODE_REQUEST"),
    1048576: .same(proto: "BLACKLIST_USER"),
    2097152: .same(proto: "REMOTE_START"),
  ]
}

extension VehicleSecureConditionsFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SECURE_CONDITION_NONE"),
    1: .same(proto: "WINDOWS_UP"),
    2: .same(proto: "SUNROOF_CLOSED"),
    4: .same(proto: "CONVERTIBLE_CLOSED"),
    8: .same(proto: "DOORS_CLOSED"),
    16: .same(proto: "IGNITION_OFF"),
    32: .same(proto: "LIGHTS_OFF"),
  ]
}

extension AppToDeviceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AppToDeviceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  fileprivate class _StorageClass {
    var _message: AppToDeviceMessage.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: DeviceCommandMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .command(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .command(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .command(let v)? = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AppToDeviceMessage, rhs: AppToDeviceMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceToAppMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceToAppMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _message: DeviceToAppMessage.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: ResultMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .result(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .result(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .result(let v)? = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceToAppMessage, rhs: DeviceToAppMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceCommandMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceCommandMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed32Field(value: &self.command)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != 0 {
      try visitor.visitSingularFixed32Field(value: self.command, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceCommandMessage, rhs: DeviceCommandMessage) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceCommandMessage.Command: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_COMMAND"),
    1: .same(proto: "LOCK"),
    2: .same(proto: "UNLOCK_DRIVER"),
    4: .same(proto: "UNLOCK_ALL"),
    8: .same(proto: "OPEN_TRUNK"),
    16: .same(proto: "CLOSE_TRUNK"),
    32: .same(proto: "LOCATE"),
    64: .same(proto: "IMMOBILIZE"),
    128: .same(proto: "MOBILIZE"),
    1024: .same(proto: "CHECKIN"),
    2048: .same(proto: "CHECKOUT"),
  ]
}

extension ResultMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResultMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResultMessage, rhs: ResultMessage) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceReservationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceReservationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_public_modulus"),
    2: .standard(proto: "key_expiry"),
    3: .standard(proto: "reservation_id"),
    4: .standard(proto: "device_hardware_id"),
    5: .same(proto: "account"),
    6: .standard(proto: "reservation_start_time"),
    7: .standard(proto: "reservation_end_time"),
    8: .standard(proto: "grace_period_seconds"),
    9: .standard(proto: "secure_period_seconds"),
    10: .standard(proto: "end_book_conditions"),
    11: .standard(proto: "prox_card_id"),
  ]

  fileprivate class _StorageClass {
    var _appPublicModulus: Data = SwiftProtobuf.Internal.emptyData
    var _keyExpiry: UInt64 = 0
    var _reservationID: String = String()
    var _deviceHardwareID: UInt64 = 0
    var _account: Account? = nil
    var _reservationStartTime: UInt64 = 0
    var _reservationEndTime: UInt64 = 0
    var _gracePeriodSeconds: UInt32 = 0
    var _securePeriodSeconds: UInt32 = 0
    var _endBookConditions: EndBookConditions? = nil
    var _proxCardID: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _appPublicModulus = source._appPublicModulus
      _keyExpiry = source._keyExpiry
      _reservationID = source._reservationID
      _deviceHardwareID = source._deviceHardwareID
      _account = source._account
      _reservationStartTime = source._reservationStartTime
      _reservationEndTime = source._reservationEndTime
      _gracePeriodSeconds = source._gracePeriodSeconds
      _securePeriodSeconds = source._securePeriodSeconds
      _endBookConditions = source._endBookConditions
      _proxCardID = source._proxCardID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._appPublicModulus)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._keyExpiry)
        case 3: try decoder.decodeSingularStringField(value: &_storage._reservationID)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._deviceHardwareID)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._reservationStartTime)
        case 7: try decoder.decodeSingularUInt64Field(value: &_storage._reservationEndTime)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._gracePeriodSeconds)
        case 9: try decoder.decodeSingularUInt32Field(value: &_storage._securePeriodSeconds)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._endBookConditions)
        case 11: try decoder.decodeSingularUInt32Field(value: &_storage._proxCardID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._appPublicModulus.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appPublicModulus, fieldNumber: 1)
      }
      if _storage._keyExpiry != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._keyExpiry, fieldNumber: 2)
      }
      if !_storage._reservationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reservationID, fieldNumber: 3)
      }
      if _storage._deviceHardwareID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._deviceHardwareID, fieldNumber: 4)
      }
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._reservationStartTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._reservationStartTime, fieldNumber: 6)
      }
      if _storage._reservationEndTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._reservationEndTime, fieldNumber: 7)
      }
      if _storage._gracePeriodSeconds != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gracePeriodSeconds, fieldNumber: 8)
      }
      if _storage._securePeriodSeconds != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._securePeriodSeconds, fieldNumber: 9)
      }
      if let v = _storage._endBookConditions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._proxCardID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._proxCardID, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceReservationMessage, rhs: DeviceReservationMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._appPublicModulus != rhs_storage._appPublicModulus {return false}
        if _storage._keyExpiry != rhs_storage._keyExpiry {return false}
        if _storage._reservationID != rhs_storage._reservationID {return false}
        if _storage._deviceHardwareID != rhs_storage._deviceHardwareID {return false}
        if _storage._account != rhs_storage._account {return false}
        if _storage._reservationStartTime != rhs_storage._reservationStartTime {return false}
        if _storage._reservationEndTime != rhs_storage._reservationEndTime {return false}
        if _storage._gracePeriodSeconds != rhs_storage._gracePeriodSeconds {return false}
        if _storage._securePeriodSeconds != rhs_storage._securePeriodSeconds {return false}
        if _storage._endBookConditions != rhs_storage._endBookConditions {return false}
        if _storage._proxCardID != rhs_storage._proxCardID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "permissions"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _permissions: PermissionList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _permissions = source._permissions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._permissions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._permissions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account, rhs: Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._permissions != rhs_storage._permissions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PermissionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed32Field(value: &self.permissions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.permissions != 0 {
      try visitor.visitSingularFixed32Field(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PermissionList, rhs: PermissionList) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EndBookConditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EndBookConditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_secure_conditions"),
    2: .standard(proto: "home_point"),
    3: .standard(proto: "home_radius"),
    4: .standard(proto: "fuel_tank_greater_than"),
  ]

  fileprivate class _StorageClass {
    var _vehicleSecureConditions: VehicleSecureConditions? = nil
    var _homePoint: GpsCoordinate? = nil
    var _homeRadius: UInt32 = 0
    var _fuelTankGreaterThan: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _vehicleSecureConditions = source._vehicleSecureConditions
      _homePoint = source._homePoint
      _homeRadius = source._homeRadius
      _fuelTankGreaterThan = source._fuelTankGreaterThan
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._vehicleSecureConditions)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._homePoint)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._homeRadius)
        case 4: try decoder.decodeSingularFloatField(value: &_storage._fuelTankGreaterThan)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._vehicleSecureConditions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._homePoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._homeRadius != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._homeRadius, fieldNumber: 3)
      }
      if _storage._fuelTankGreaterThan != 0 {
        try visitor.visitSingularFloatField(value: _storage._fuelTankGreaterThan, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EndBookConditions, rhs: EndBookConditions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._vehicleSecureConditions != rhs_storage._vehicleSecureConditions {return false}
        if _storage._homePoint != rhs_storage._homePoint {return false}
        if _storage._homeRadius != rhs_storage._homeRadius {return false}
        if _storage._fuelTankGreaterThan != rhs_storage._fuelTankGreaterThan {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleSecureConditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleSecureConditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_secure_conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed32Field(value: &self.vehicleSecureConditions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vehicleSecureConditions != 0 {
      try visitor.visitSingularFixed32Field(value: self.vehicleSecureConditions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleSecureConditions, rhs: VehicleSecureConditions) -> Bool {
    if lhs.vehicleSecureConditions != rhs.vehicleSecureConditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GpsCoordinate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GpsCoordinate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.latitude)
      case 2: try decoder.decodeSingularFloatField(value: &self.longitude)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GpsCoordinate, rhs: GpsCoordinate) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CarsharePublicKeyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CarsharePublicKeyMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rotation_timestamp"),
    2: .standard(proto: "public_modulus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.rotationTimestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.publicModulus)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rotationTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.rotationTimestamp, fieldNumber: 1)
    }
    if !self.publicModulus.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicModulus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CarsharePublicKeyMessage, rhs: CarsharePublicKeyMessage) -> Bool {
    if lhs.rotationTimestamp != rhs.rotationTimestamp {return false}
    if lhs.publicModulus != rhs.publicModulus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
